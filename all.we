use "file.we" as file

# only multiple return, no expression lists or tuple type. Just use records.
# forced explicit ignoring of return values. each one, specify a type if you want to make sure you're correct about the type.
# builtin functions size_in_bytes<T>, alignment_in_bytes<T>, reallocate, allocate, free, store<T>, load<T>, to_string<T>
# [length Type] is coerced and cloned into [Type] or mut [Type]. (Using it with mut is weird though)
# inferred generic arguments. (Help users when the compiler cannot figure it out)
# generic expressions.
# capitalized Types.
# functions can have the same name as long as the type is different. adding mut counts as a different type
# mut keyword before any variable needing to be changed.
# functions cannot mutate outer state.
# equality checks list/set/map/record/variant contents.
# assignments clone by default.
# usually you don't need to declare a type. Unless shadowing or casting.
# repeat with only number.
# no memory safety. mutate memory whenever you want.
# asserts are run at compile time if possible.
# records and variants are only data.

function assert<condition Bool>()
    if not condition
        panic()

function assert(condition Bool)
    if not condition
        panic()

function hello<length>(name [length U8])
    name [U8] = name
    hello(name)

function hello(name [U8])
    output(join(["Hello ", name, "!\n"]))

hello("Guest")

output("What's your name?\n")
name = input()
hello(name)

mut hash = 0
i = 0
repeat name.length
    hash = hash + get(name, i)
    i = i + 1

if hash > 60
    output("Wowzies that's big\n")
else if hash > 40
    output("That's still prettie big!\n")
else
    output("Eeh, size doesn't matter anyway\n")

variant Result
    unknown
    yes U64
    nah Bool

record Thing
    field U8
    other_thing S8

thing = Thing
    field 'u'
    other_thing - 4

result Result = .uknown
result Result = .yes 64

x, _ U8, y = do_thing(1, 2, 3)

mut x = 0

function thing() # Pass it as a parameter "function thing(mut x S64)"
    x = x + 1 # Error

x U8 = 1

function thing2() # This is fine because x is immutable.
    output([x]) # Make it into a list to make output accept it

thing3 = thing2
thing3() # Works.
